/*
 * 函数功能：计算一个数字字符串可以被解码的方式数量
 * 参数说明：
 *   s：代表一个数字字符串，其中数字范围是 ['0', '9']
 * 返回值说明：
 *   返回一个整数，代表字符串可以被解码的方式数量
 * 
 * 解码规则：
 *   - 字符串中的每个数字字符代表一个字母，'1' 对应 'A'，'2' 对应 'B'，依此类推。
 *   - 两个数字字符可以合并表示一个字母，但合并的数字必须在 10~26 之间。
 *   - 如果字符串的第一个字符是 '0'，则无法解码，直接返回 0。
 *   - 使用动态规划方法计算解码方式数量，dp[i] 表示从字符串开始到第 i 个字符的解码方式数量。
 */
int numDecodings(char *s)
{
    // 获取字符串长度
    int n = strlen(s);
    // 如果字符串的第一个字符是 '0'，无法解码，直接返回 0
    if (s[0] == '0')
        return 0;
    
    // 定义动态规划数组 dp，用于计算解码方式数量
    int dp[n + 1];
    // 初始化 dp 数组为 0
    memset(dp, 0, sizeof(dp));
    // 初始化 dp[0] 为 1，表示空字符串有一种解码方式
    dp[0] = 1;
    
    // 遍历字符串，计算解码方式数量
    for (int i = 1; i <= n; i++)
    {
        // 如果当前字符不是 '0'，则当前字符可以单独解码，继承上一个字符的解码数量
        if (s[i - 1] != '0')
            dp[i] = dp[i - 1];
        // 如果当前字符可以与上一个字符合并解码，并且合并的数字在 10~26 之间
        if (i > 1 && (s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] <= '6')))
            // 则加上前两个字符的解码数量，表示当前字符既可以单独解码也可以合并解码
            dp[i] += dp[i - 2];
    }
    // 返回字符串的解码方式数量
    return dp[n];
}